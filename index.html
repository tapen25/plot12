<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Walking Interaction: Timbre Agency</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #f0f0f0; }
  #status { font-size: 1.2rem; margin: 10px 0; font-weight: bold; }
  #debug { 
    background: #333; color: #0f0; padding: 10px; 
    border-radius: 5px; font-family: monospace; white-space: pre-wrap;
  }
  button { padding: 10px 20px; font-size: 1rem; cursor: pointer; }
</style>
</head>
<body>

<h3>歩行インタラクション実験 (Timbre Agency)</h3>
<p>BPMは4秒平均で安定追従、音色(明るさ)は入力エネルギーに敏感に反応します。</p>

<button id="start">Start (Sensor & Audio)</button>
<div id="status">停止中</div>
<div id="debug">Waiting...</div>

<script>
let audioCtx;
let isPlaying = false;

// ---------------------------
// パラメータ設定
// ---------------------------
// BPM計算用の履歴期間（4秒＝安定重視）
const BPM_HISTORY_DURATION = 4000;
// 音色計算用の履歴期間（0.5秒＝応答性重視）
const TIMBRE_HISTORY_DURATION = 500;

// データ履歴
let motionHistory = []; 

// 状態変数
let currentBPM = 60;        // 現在のBPM
let currentEnergy = 0;      // 現在の運動エネルギー(0.0 - 1.0)
let targetCutoff = 400;     // フィルター周波数(Hz)
let targetVolume = 0.3;     // 音量

// スケジューリング用
let nextBarTime = 0;
let usePatternA = true;

// ---------------------------
// 音楽データ定義
// ---------------------------
const patterns = {
  // 少しメロディアスに
  A: ["C4","C4","G4","G4","A4","A4","G4",null], 
  B: ["F4","F4","E4","E4","D4","D4","C4",null]
};
// 全て4分音符
const durations = [1,1,1,1,1,1,1,1]; 

// 音名→周波数変換
function noteToFreq(note) {
  if(!note) return 0;
  const notes = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const octave = parseInt(note.slice(-1));
  const key = note.slice(0, -1);
  const semitone = notes.indexOf(key);
  const A4 = 440;
  const distFromA4 = (octave - 4) * 12 + (semitone - 9);
  return A4 * Math.pow(2, distFromA4 / 12);
}

// ---------------------------
// 初期化処理
// ---------------------------
document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
  }

  // iOS 13+ 加速度センサー許可
  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    try {
      await DeviceMotionEvent.requestPermission();
    } catch (e) {
      console.error(e);
    }
  }

  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "歩いてください (センサー作動中)";
  
  // シーケンス強制開始（音は出るが、最初は遅く・こもっている）
  if (!isPlaying) startSequence();
};

// ---------------------------
// センサー処理 (Dual Smoothing)
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity; // 重力込みの方が「揺れ」を拾いやすい場合があるため
  if (!acc) return;

  // ベクトル合成（重力成分を除去するために簡易的なハイパスフィルタ相当の処理を入れるのが理想だが、ここでは変化量を見る）
  // 簡易的に重力加速度(約9.8)を引いた絶対値の変動を見る
  const x = acc.x || 0;
  const y = acc.y || 0;
  const z = acc.z || 0;
  const mag = Math.sqrt(x*x + y*y + z*z);
  
  // 静止時が約9.8なので、そこからの振れ幅を取得
  const diff = Math.abs(mag - 9.8); 

  const now = performance.now();
  motionHistory.push({ time: now, val: diff });

  // 古い履歴を削除 (最大4秒分保持)
  motionHistory = motionHistory.filter(i => now - i.time < BPM_HISTORY_DURATION);

  // 1. BPM用の計算 (4秒間の平均 -> 安定)
  const bpmAvg = getAverageMagnitude(motionHistory, BPM_HISTORY_DURATION);
  // 加速度 1.0(ゆっくり)〜8.0(激しい) を BPM 60〜140 にマップ
  let targetBPM = 60 + (bpmAvg * 10); 
  targetBPM = Math.min(Math.max(targetBPM, 60), 160); // Clamp
  
  // BPMをゆっくり追従させる (急激な変化を防ぐ)
  currentBPM += (targetBPM - currentBPM) * 0.05; 

  // 2. 音色(Timbre)用の計算 (0.5秒間の平均 -> 高反応)
  const timbreAvg = getAverageMagnitude(motionHistory, TIMBRE_HISTORY_DURATION);
  // エネルギーレベル (0.0 〜 1.0)
  currentEnergy = Math.min(timbreAvg / 6.0, 1.0); 

  // マッピング: 
  // 低エネルギー: 400Hz (こもった音) 〜 高エネルギー: 3000Hz (明るい音)
  targetCutoff = 400 + (currentEnergy * 2600);
  
  // マッピング: 音量
  // 低エネルギー: 小さい 〜 高エネルギー: 大きい
  targetVolume = 0.2 + (currentEnergy * 0.5);

  updateDebugDisplay();
}

function getAverageMagnitude(history, durationMs) {
  const now = performance.now();
  const targetItems = history.filter(i => now - i.time < durationMs);
  if (targetItems.length === 0) return 0;
  const sum = targetItems.reduce((a, b) => a + b.val, 0);
  return sum / targetItems.length;
}

function updateDebugDisplay() {
  const bar = "█".repeat(Math.floor(currentEnergy * 20));
  document.getElementById("debug").innerText = 
    `BPM    : ${Math.floor(currentBPM)} (安定)\n` +
    `Timbre : ${Math.floor(targetCutoff)}Hz (敏感)\n` +
    `Energy : [${bar.padEnd(20, " ")}]`;
}

// ---------------------------
// シーケンス制御
// ---------------------------
function startSequence() {
  isPlaying = true;
  nextBarTime = audioCtx.currentTime + 0.1;
  loop();
}

function loop() {
  // 先読みスケジューリング (25ms間隔でチェック)
  const now = audioCtx.currentTime;
  // lookahead: 0.1秒
  if (nextBarTime < now + 0.1) {
    scheduleBar(nextBarTime);
  }
  requestAnimationFrame(loop);
}

function scheduleBar(startTime) {
  const pattern = usePatternA ? patterns.A : patterns.B;
  const secondsPerBeat = 60.0 / currentBPM; // 現在の平均BPMを使用
  
  let noteTime = startTime;

  pattern.forEach((note, index) => {
    if (note) {
      // 発音時に現在のターゲットパラメータを渡す
      playTone(note, noteTime, secondsPerBeat, targetCutoff, targetVolume);
    }
    noteTime += secondsPerBeat;
  });

  // 次の小節の開始時間
  nextBarTime += secondsPerBeat * pattern.length;
  usePatternA = !usePatternA;
}

// ---------------------------
// 音声合成 (Sawtooth + LPF)
// ---------------------------
function playTone(note, time, duration, cutoff, volume) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();

  // 1. オシレーター設定 (ノコギリ波＝倍音が豊富)
  osc.type = "sawtooth";
  osc.frequency.value = noteToFreq(note);

  // 2. フィルター設定 (ここが「主体感」のキモ)
  filter.type = "lowpass";
  filter.Q.value = 5; // レゾナンスを少し入れて変化をわかりやすくする
  // フィルターのエンベロープ (アタック感)
  filter.frequency.setValueAtTime(cutoff, time);
  // 少し減衰させることで楽器らしさを出す
  filter.frequency.exponentialRampToValueAtTime(Math.max(cutoff * 0.5, 100), time + duration - 0.05);

  // 3. アンプ設定 (音量)
  gain.gain.setValueAtTime(0, time);
  gain.gain.linearRampToValueAtTime(volume, time + 0.05);
  gain.gain.exponentialRampToValueAtTime(0.001, time + duration - 0.05);

  // 接続
  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);

  // 再生
  osc.start(time);
  osc.stop(time + duration);
}
</script>
</body>
</html>