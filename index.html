<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Walking Agency: Multi-Layer Tone</title>
<style>
  body { font-family: sans-serif; padding: 20px; text-align: center; background: #f0f0f0; user-select: none; }
  button { font-size: 1.2rem; padding: 15px 30px; border-radius: 8px; border: none; background: #007AFF; color: white; cursor: pointer; }
  #status { margin-top: 20px; font-weight: bold; font-size: 1.2rem; }
  #debug { margin-top: 10px; color: #555; font-family: monospace; font-size: 1.2rem;}
  #params { margin-top: 10px; font-size: 0.9rem; color: #333; height: 1.2em; }
</style>
</head>
<body>

<button id="start">Start (iOSã¯è¦ã‚¿ãƒƒãƒ—)</button>
<div id="status">åœæ­¢ä¸­</div>
<div id="debug">BPM: 100</div>
<div id="params"></div>

<script>
let audioCtx;
let isPlaying = false;

// ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ‡æ›¿
let usePatternA = true;

// å¹³å‡BPMï¼ˆåˆæœŸå€¤ã¯ç¯„å›²ã®ä¸‹é™ã«ï¼‰
let smoothedBPM = 100;

// åŠ é€Ÿåº¦ã®å±¥æ­´
let motionHistory = [];
const HISTORY_DURATION = 4000; 

// å°ç¯€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ç”¨
let nextBarTime = 0;

// ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
const patterns = {
  A: ["D4","C4","B3","D4","C4","A3","G3","A3","B3"],
  B: ["D4","C4","B3","D4","C4","A3","G3","B3","G3"]
};

// ãƒªã‚ºãƒ ï¼ˆ4åˆ†ï¼1.0ï¼‰
const durations = [0.25,0.25,0.25,0.25,0.5,0.5,0.5,0.5,1.0];

// éŸ³åâ†’å‘¨æ³¢æ•°
function noteToFreq(note) {
  const map = {
    G3:-14, A3:-12, B3:-10,
    C4:-9,  D4:-7,  E4:-5, F4:-4, G4:-2, A4:0, B4:2,
    C5:3
  };
  let semitone = map[note] ?? 0;
  return 440 * Math.pow(2, semitone/12);
}

document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
  }

  // iOS Permission
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const permissionState = await DeviceMotionEvent.requestPermission();
      if (permissionState !== 'granted') {
        alert("ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ãŒå¿…è¦ã§ã™");
        return;
      }
    } catch (e) { console.error(e); }
  }

  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "æ­©è¡Œå¾…æ©Ÿä¸­...";
  document.getElementById("start").style.display = 'none';
};

// ---------------------------
// ã‚»ãƒ³ã‚µãƒ¼å‡¦ç†
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;

  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({time: now, val: mag});
  
  // å±¥æ­´æœŸé–“å¤–ã‚’å‰Šé™¤
  while(motionHistory.length > 0 && now - motionHistory[0].time > HISTORY_DURATION) {
    motionHistory.shift();
  }

  // å¹³å‡è¨ˆç®—
  let sum = 0;
  motionHistory.forEach(i => sum += i.val);
  const avg = sum / motionHistory.length || 0;

  smoothedBPM = mapAccelToBPM(avg);

  // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
  let statusIcon = "ğŸš¶";
  if (smoothedBPM > 115) statusIcon = "ğŸƒ";
  if (smoothedBPM > 125) statusIcon = "ğŸ”¥";
  
  document.getElementById("debug").innerText = 
    `BPM: ${Math.floor(smoothedBPM)} ${statusIcon}`;

  // éŸ³è‰²ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®å¯è¦–åŒ–
  const mix = getMixParams(smoothedBPM);
  document.getElementById("params").innerText = 
    `XyloMix: ${(mix.xyloGain*100).toFixed(0)}% | Brightness: ${(mix.filterFreq/1000).toFixed(1)}`;

  // é–‹å§‹ãƒˆãƒªã‚¬ãƒ¼
  if (!isPlaying && mag > 12) {
    startSequence();
  }
}

// ---------------------------
// BPMãƒãƒƒãƒ”ãƒ³ã‚° (100ã€œ130)
// ---------------------------
function mapAccelToBPM(a) {
  // é‡åŠ›9.8ã‚’é™¤ã„ãŸå‹•ãæˆåˆ†
  let val = a - 9.8; 
  if (val < 0) val = 0;

  // æ„Ÿåº¦èª¿æ•´: 
  // è»½ã„æ­©ã(val=1ã€œ2) -> 100ä»˜è¿‘
  // ã—ã£ã‹ã‚Šæ­©ã(val=5ã€œ6) -> 130ä»˜è¿‘
  let bpm = 100 + (val * 6.0); 

  if (bpm < 100) bpm = 100;
  if (bpm > 130) bpm = 130;
  return bpm;
}

// ---------------------------
// éŸ³è‰²ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ç®—å‡º
// ---------------------------
function getMixParams(bpm) {
  // ç¯„å›² 100ã€œ130 ã«å¯¾ã™ã‚‹ 0.0ã€œ1.0 ã®æ­£è¦åŒ–å€¤
  let t = (bpm - 100) / 30; 
  if (t < 0) t = 0; if (t > 1) t = 1;

  // 1. ãƒ™ãƒ¼ã‚¹éŸ³ã®æ˜ã‚‹ã• (LPF Cutoff)
  // 100bpm: 800Hz (ã“ã‚‚ã£ãŸéŸ³) -> 130bpm: 3000Hz (æ˜ã‚‹ã„éŸ³)
  const filterFreq = 800 + t * 2200;

  // 2. ãƒ™ãƒ¼ã‚¹éŸ³ã®ã‚¢ã‚¿ãƒƒã‚¯æ„Ÿ (Attack Time)
  // BPMãŒä¸ŠãŒã‚‹ã¨ã‚¢ã‚¿ãƒƒã‚¯ã‚’é€Ÿãã—ã¦ã‚­ãƒ¬ã‚’å‡ºã™ (0.08s -> 0.02s)
  const attackTime = 0.08 - t * 0.06;

  // 3. ã‚·ãƒ­ãƒ•ã‚©ãƒ³(ç²’éŸ³)ã®æ··ã–ã‚Šå…·åˆ
  // BPM 115 (t=0.5) ã‚ãŸã‚Šã‹ã‚‰æ··ãœå§‹ã‚ã‚‹
  let xyloGain = 0;
  if (t > 0.5) {
    // 0.5ã€œ1.0 ã®ç¯„å›²ã‚’ 0.0ã€œ1.0 ã«ãƒãƒƒãƒ—
    xyloGain = (t - 0.5) * 2.0; 
    // æœ€å¤§éŸ³é‡ã¯å°‘ã—æ§ãˆã‚ã«
    xyloGain *= 0.6; 
  }

  return { filterFreq, attackTime, xyloGain };
}

// ---------------------------
// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹åˆ¶å¾¡
// ---------------------------
function startSequence() {
  isPlaying = true;
  nextBarTime = audioCtx.currentTime + 0.1; 
  document.getElementById("status").innerText = "å†ç”Ÿä¸­";
}

function scheduleBar() {
  const pattern = usePatternA ? patterns.A : patterns.B;
  const beatDur = 60 / smoothedBPM;
  const now = audioCtx.currentTime;
  
  if (nextBarTime < now) nextBarTime = now + 0.05;

  let cursor = nextBarTime;
  
  // å°ç¯€ã®é ­ã§éŸ³è‰²ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ±ºå®š
  const params = getMixParams(smoothedBPM);

  for (let i = 0; i < pattern.length; i++) {
    const beatLen = durations[i];
    const durSec = beatLen * beatDur;
    const freq = noteToFreq(pattern[i]);

    // 2ã¤ã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åŒæ™‚ã«é³´ã‚‰ã™
    playLayeredTone(freq, cursor, durSec, params);
    
    cursor += durSec;
  }

  const totalBeats = durations.reduce((a,b)=>a+b, 0);
  nextBarTime += totalBeats * beatDur;
  usePatternA = !usePatternA;
}

// ---------------------------
// éŸ³å£°åˆæˆ (ãƒ¬ã‚¤ãƒ¤ãƒªãƒ³ã‚°)
// ---------------------------
function playLayeredTone(freq, time, dur, params) {
  // --- Layer 1: Base (ç¬›ã€œã‚¹ãƒˆãƒªãƒ³ã‚°ã‚¹) ---
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  const filter1 = audioCtx.createBiquadFilter();

  osc1.type = "sawtooth"; // å€éŸ³è±Šã‹ãªæ³¢å½¢ã‚’ãƒ™ãƒ¼ã‚¹ã«ã™ã‚‹
  osc1.frequency.value = freq;

  filter1.type = "lowpass";
  filter1.frequency.value = params.filterFreq;
  filter1.Q.value = 1;

  osc1.connect(filter1).connect(gain1).connect(audioCtx.destination);

  // Envelope for Base
  const atk = params.attackTime;
  const rel = dur * 0.5;
  
  gain1.gain.setValueAtTime(0, time);
  gain1.gain.linearRampToValueAtTime(0.4, time + atk);
  gain1.gain.exponentialRampToValueAtTime(0.001, time + dur - 0.05);

  osc1.start(time);
  osc1.stop(time + dur);


  // --- Layer 2: Xylophone (ç²’éŸ³) ---
  // xyloGain ãŒ 0 ã‚ˆã‚Šå¤§ãã„æ™‚ã ã‘é³´ã‚‰ã™
  if (params.xyloGain > 0.01) {
    const osc2 = audioCtx.createOscillator();
    const gain2 = audioCtx.createGain();

    osc2.type = "sine"; // ä¸¸ã„éŸ³
    // 1ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Šã‚’æ··ãœã‚‹ã¨ã‚ˆã‚Šç…Œã³ã‚„ã‹ã«ãªã‚‹ãŒã€
    // ã“ã“ã§ã¯åŒéŸ³ç¨‹ã§ã€ŒèŠ¯ã€ã‚’ä½œã‚‹
    osc2.frequency.value = freq; 

    osc2.connect(gain2).connect(audioCtx.destination);

    // Envelope for Xylo (çŸ­ãå©ãéŸ³)
    gain2.gain.setValueAtTime(0, time);
    gain2.gain.linearRampToValueAtTime(params.xyloGain, time + 0.01); // å³åº§ã«ç«‹ã¡ä¸ŠãŒã‚Š
    gain2.gain.exponentialRampToValueAtTime(0.001, time + 0.15); // ã™ãæ¶ˆãˆã‚‹

    osc2.start(time);
    osc2.stop(time + 0.2); // éŸ³è‡ªä½“ã¯çŸ­ãã¦è‰¯ã„
  }
}

// ---------------------------
// ãƒ«ãƒ¼ãƒ—
// ---------------------------
setInterval(() => {
  if (!isPlaying) return;
  const now = audioCtx.currentTime;
  if (nextBarTime - now < 0.1) {
    scheduleBar();
  }
}, 25);
</script>

</body>
</html>