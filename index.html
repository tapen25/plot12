<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>BPMè¿½å¾“ã‚·ãƒ¼ã‚±ãƒ³ã‚µ</title>
</head>
<body>
<button id="start">Start (iOSã¯è¦ã‚¿ãƒƒãƒ—)</button>
<div id="status">åœæ­¢ä¸­</div>
<div id="debug">BPM: 0</div>

<script>
let audioCtx;
let usePatternA = true;
let isPlaying = false;
let smoothedBPM = 60;
let motionHistory = [];
const HISTORY_DURATION = 2000; // ms

// ãƒ‘ã‚¿ãƒ¼ãƒ³ / ãƒªã‚ºãƒ 
const patterns = {
  A: ["D4","C4","B3","D4", "C4","A3", "G3","A3", "B3"],
  B: ["D4","C4","B3","D4", "C4","A3", "G3","B3", "G3"]
};
const durations = [0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.5, 0.5, 1.0];

// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ç®¡ç†
let tempoAtStart = 120;       // ç¾åœ¨é©ç”¨ä¸­ã®ãƒ†ãƒ³ãƒï¼ˆå°ç¯€é ­ã§æ›´æ–°ï¼‰
let pendingTempo = null;      // æ¬¡ã®å°ç¯€é ­ã§é©ç”¨ã™ã‚‹ãƒ†ãƒ³ãƒï¼ˆnullã§æœªäºˆç´„ï¼‰
let sequenceStartTime = 0;    // æ¬¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ¶å¯¾é–‹å§‹æ™‚åˆ» (audioCtx.currentTime åŸºæº–)
let scheduledFinishTimer = null;
let tempoWatchTimer = null;
let devMotionAttached = false;

// ãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡ï¼ˆè¶³éŸ³ç”¨ï¼‰
let noiseBuffer = null;

// ---------------------------
// éŸ³å -> å‘¨æ³¢æ•°
// ---------------------------
function noteToFreq(note, offset = 0) {
  const map = {
    G3: -14, A3: -12, B3: -10,
    C4: -9,  D4: -7,  E4: -5, F4: -4, G4: -2, A4: 0, B4: 2,
    C5: 3
  };
  let semitone = map[note];
  if (semitone === undefined) semitone = 0;
  semitone += offset;
  return 440 * Math.pow(2, semitone / 12);
}

// ---------------------------
// ãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡ä½œæˆï¼ˆè¶³éŸ³ç”¨ï¼‰
// ---------------------------
function ensureNoiseBuffer() {
  if (!audioCtx || noiseBuffer) return;
  const len = audioCtx.sampleRate * 0.2; // 0.2s ã®çŸ­ã„ãƒã‚¤ã‚º
  const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++) {
    // çŸ­ã„ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¤ã‚ºï¼ˆå¾ã€…ã«æ¸›è¡°ï¼‰
    data[i] = (Math.random() * 2 - 1) * (1 - i / len);
  }
  noiseBuffer = buf;
}

// ---------------------------
// ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
// ---------------------------
document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }

  ensureNoiseBuffer();

  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    try { await DeviceMotionEvent.requestPermission(); } catch(e) { /* iOS ã§æ‹’å¦ã•ã‚ŒãŸã‚‰ç„¡è¦– */ }
  }
  if (!devMotionAttached) {
    window.addEventListener("devicemotion", handleMotion);
    devMotionAttached = true;
  }

  if (!isPlaying) {
    startSequence();
  }
};

// ---------------------------
// ã‚»ãƒ³ã‚µãƒ¼å‡¦ç†ï¼ˆ2ç§’å¹³å‡ã§BPMç®—å‡ºï¼‰
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;
  const mag = Math.sqrt((acc.x||0)**2 + (acc.y||0)**2 + (acc.z||0)**2);
  const now = performance.now();
  motionHistory.push({ time: now, val: mag });
  motionHistory = motionHistory.filter(item => now - item.time < HISTORY_DURATION);
  let sum = 0;
  motionHistory.forEach(item => sum += item.val);
  const avgMag = sum / (motionHistory.length || 1);
  smoothedBPM = mapAccelToBPM(avgMag);
  const isHighSpeed = smoothedBPM >= 120;
  document.getElementById("debug").innerText = `Avg BPM: ${Math.floor(smoothedBPM)} ${isHighSpeed ? "ğŸ”¥HIGH" : ""}`;

  // åœæ­¢ä¸­ã§å¼·ãæŒ¯ã£ãŸã‚‰é–‹å§‹
  if (!isPlaying && mag > 15) {
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let bpm = 100 + (a - 10) * 8;
  if (bpm < 60) bpm = 60;
  if (bpm > 200) bpm = 200;
  return bpm;
}

// ---------------------------
// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹ï¼ˆæœ€åˆã®å°ç¯€ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
// ---------------------------
function startSequence() {
  if (!audioCtx) return;
  isPlaying = true;
  usePatternA = true;
  tempoAtStart = Math.max(60, Math.min(200, Math.round(smoothedBPM)));
  pendingTempo = null;
  sequenceStartTime = audioCtx.currentTime + 0.05;
  schedulePattern(usePatternA, tempoAtStart, sequenceStartTime);

  // ãƒ†ãƒ³ãƒå¤‰åŒ–ã‚’ç›£è¦–ã—ã¦ã€Œæ¬¡ã®å°ç¯€é ­ã€ã§é©ç”¨ã™ã‚‹ãŸã‚ã®ã‚¿ã‚¤ãƒãƒ¼
  if (tempoWatchTimer) clearInterval(tempoWatchTimer);
  tempoWatchTimer = setInterval(() => {
    const bpmRounded = Math.max(60, Math.min(200, Math.round(smoothedBPM)));
    if (Math.abs(bpmRounded - tempoAtStart) >= 2) {
      pendingTempo = bpmRounded;
    }
  }, 150);
}

// ---------------------------
// ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’çµ¶å¯¾æ™‚é–“ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆ1ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†ã®ã¿ï¼‰
// ---------------------------
function schedulePattern(isA, tempo, startTime) {
  if (!audioCtx) return;
  const pattern = isA ? patterns.A : patterns.B;
  let accumBeats = 0;
  const beatDuration = 60 / tempo;

  // éŸ³ç¬¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  pattern.forEach((noteName, idx) => {
    const durationVal = durations[idx];
    const noteStart = startTime + accumBeats * beatDuration;
    const noteLen = beatDuration * durationVal;

    // åŸºæœ¬ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    const baseOffset = (tempo >= 120) ? 1 : 0;

    // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼é¸å®šï¼ˆãƒ†ãƒ³ãƒåŸºæº–ã§æ±ºå®šï¼‰
    let harmonyIntervals = [0];
    if (tempo >= 160) {
      harmonyIntervals = [0, 4, 7];
    } else if (tempo >= 120) {
      harmonyIntervals = [0, 4];
    }
    const freqs = harmonyIntervals.map(i => noteToFreq(noteName, baseOffset + i));

    // éŸ³ã‚’äºˆç´„
    playTone(freqs, noteStart, noteLen);

    // UIæ›´æ–°ï¼ˆè©²å½“ãƒãƒ¼ãƒˆãŒå§‹ã¾ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§è¡¨ç¤ºï¼‰
    const uiDelay = (noteStart - audioCtx.currentTime) * 1000;
    setTimeout(() => {
      document.getElementById("status").innerText =
        `å†ç”Ÿä¸­: ${isA ? "A" : "B"} (${idx+1}/${pattern.length}) ${harmonyIntervals.length>1 ? "ï¼‹ãƒãƒ¢ãƒª" : ""}`;
    }, Math.max(0, uiDelay));

    accumBeats += durationVal;
  });

  // è¶³éŸ³ã‚’ãƒ“ãƒ¼ãƒˆï¼ˆ1æ‹ã”ã¨ï¼‰ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  // å¼·èª¿ï¼ˆã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼‰ã¯å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®1æ‹ç›®ã«ã®ã¿å…¥ã‚Œã‚‹
  const totalBeats = Math.ceil(accumBeats);
  for (let b = 0; b < totalBeats; b++) {
    const t = startTime + b * beatDuration;
    const accent = (b === 0); // 1æ‹ç›®ã‚’å¼·ã
    playFootstep(t, accent);
  }

  // æ¬¡ãƒ‘ã‚¿ãƒ¼ãƒ³é–‹å§‹ã®äºˆç´„ï¼ˆå°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
  const totalDuration = accumBeats * beatDuration;
  if (scheduledFinishTimer) clearTimeout(scheduledFinishTimer);
  const finishDelay = (startTime + totalDuration - audioCtx.currentTime) * 1000 + 20;
  scheduledFinishTimer = setTimeout(() => {
    onPatternEnd();
  }, Math.max(0, finishDelay));
}

// ---------------------------
// è¶³éŸ³å†ç”Ÿï¼ˆãƒã‚¤ã‚ºãƒãƒ¼ã‚¹ãƒˆ + ãƒ•ã‚£ãƒ«ã‚¿ + ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼‰
// ---------------------------
function playFootstep(time, accent = false) {
  if (!audioCtx || !noiseBuffer) return;
  const src = audioCtx.createBufferSource();
  src.buffer = noiseBuffer;

  const filter = audioCtx.createBiquadFilter();
  filter.type = "bandpass";
  filter.frequency.value = accent ? 900 : 700;
  filter.Q = 0.7;

  const gain = audioCtx.createGain();
  const baseGain = accent ? 0.35 : 0.18;
  // çŸ­ã„ã‚¢ã‚¿ãƒƒã‚¯ã§è‡ªç„¶ãªæ¸›è¡°
  gain.gain.setValueAtTime(0.0001, time);
  gain.gain.exponentialRampToValueAtTime(baseGain, time + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);

  src.connect(filter).connect(gain).connect(audioCtx.destination);
  src.start(time);
  src.stop(time + 0.15);
}

// ---------------------------
// ã‚µã‚¦ãƒ³ãƒ‰ç”Ÿæˆï¼ˆæ—¢å­˜ã®å®Ÿè£…ã‚’æµç”¨ï¼‰
// ---------------------------
// ---------------------------
// ã‚µã‚¦ãƒ³ãƒ‰ç”Ÿæˆï¼šåŒã˜ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’é•ã†æ¥½å™¨ã§é³´ã‚‰ã™
// ---------------------------
// ...existing code...
function playTone(freqs, time, duration) {
  if (!audioCtx) return;
  // master gain ã‚’ audioCtx ã«ä¿æŒã—ã¦ä½¿ã„å›ã™
  if (!audioCtx._masterGain) {
    const mg = audioCtx.createGain();
    mg.gain.value = 0.9; // å…¨ä½“ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ èª¿æ•´ï¼ˆå¿…è¦ãªã‚‰ã“ã“ã§ä¸‹ã’ã‚‹ï¼‰
    mg.connect(audioCtx.destination);
    audioCtx._masterGain = mg;
  }
  const master = audioCtx._masterGain;

  // ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼šçŸ­ã„ãƒ•ã‚§ãƒ¼ãƒ‰ã§å®‰å…¨ã«æ­¢ã‚ã‚‹
  const stopAt = time + duration + 0.05;

  // Lead: sawtoothï¼ˆå­˜åœ¨æ„Ÿã®ã‚ã‚‹ä¸»éŸ³ï¼‰
  const leadOsc = audioCtx.createOscillator();
  const leadGain = audioCtx.createGain();
  leadOsc.type = "sawtooth";
  leadOsc.frequency.value = freqs[0];
  leadGain.gain.setValueAtTime(0.0001, time);
  leadGain.gain.linearRampToValueAtTime(0.36, time + 0.02);
  leadGain.gain.exponentialRampToValueAtTime(0.0001, time + duration);
  const leadFilter = audioCtx.createBiquadFilter();
  leadFilter.type = "lowpass";
  leadFilter.frequency.value = 6000;
  leadOsc.connect(leadFilter).connect(leadGain).connect(master);
  leadOsc.start(time);
  leadOsc.stop(stopAt);

  // Bell: é«˜åŸŸã‚’è£œã† sineï¼ˆè´ãã‚„ã™ã•å‘ä¸Šï¼‰
  const bellOsc = audioCtx.createOscillator();
  const bellGain = audioCtx.createGain();
  bellOsc.type = "sine";
  bellOsc.frequency.value = freqs[0] * 2.0; // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ä¸Šã§æ˜ç­ã«
  bellGain.gain.setValueAtTime(0.0001, time);
  bellGain.gain.linearRampToValueAtTime(0.18, time + 0.02);
  bellGain.gain.exponentialRampToValueAtTime(0.0001, time + duration);
  const bellHP = audioCtx.createBiquadFilter();
  bellHP.type = "highpass";
  bellHP.frequency.value = 700;
  bellOsc.connect(bellHP).connect(bellGain).connect(master);
  bellOsc.start(time);
  bellOsc.stop(stopAt);

  // Body: å°‘ã—ãƒ‡ãƒãƒ¥ãƒ¼ãƒ³ã—ãŸ triangleï¼ˆæ¸©ã‹ã¿ã¨åšã¿ï¼‰
  const bodyOsc = audioCtx.createOscillator();
  const bodyGain = audioCtx.createGain();
  bodyOsc.type = "triangle";
  bodyOsc.frequency.value = freqs[0];
  bodyOsc.detune.value = -12; // åŠéŸ³ä¸‹ã§å°‘ã—åšã¿ã‚’å‡ºã™
  bodyGain.gain.setValueAtTime(0.0001, time);
  bodyGain.gain.linearRampToValueAtTime(0.12, time + 0.02);
  bodyGain.gain.exponentialRampToValueAtTime(0.0001, time + duration);
  bodyOsc.connect(bodyGain).connect(master);
  bodyOsc.start(time);
  bodyOsc.stop(stopAt);

  // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ãŒã‚ã‚Œã°ä½ã‚ã®ã‚µãƒ–ã§è£œå¼·ï¼ˆå°ã•ã‚ã®éŸ³é‡ï¼‰
  for (let i = 1; i < freqs.length; i++) {
    const f = freqs[i];
    const hOsc = audioCtx.createOscillator();
    const hGain = audioCtx.createGain();
    hOsc.type = "sine";
    hOsc.frequency.value = f;
    hGain.gain.setValueAtTime(0.0001, time);
    hGain.gain.linearRampToValueAtTime(0.08, time + 0.02);
    hGain.gain.exponentialRampToValueAtTime(0.0001, time + duration);
    // è»½ããƒ­ãƒ¼ãƒ‘ã‚¹ã§ä¸¸ã‚ã‚‹
    const hLP = audioCtx.createBiquadFilter();
    hLP.type = "lowpass";
    hLP.frequency.value = 2500;
    hOsc.connect(hLP).connect(hGain).connect(master);
    hOsc.start(time);
    hOsc.stop(stopAt);
  }
}
// ...existing code...


// ---------------------------
// åœæ­¢å‡¦ç†ï¼ˆå¿…è¦ãªã‚‰å¤–éƒ¨ã§å‘¼ã¹ã‚‹ï¼‰
// ---------------------------
function finishSequence() {
  if (scheduledFinishTimer) {
    clearTimeout(scheduledFinishTimer);
    scheduledFinishTimer = null;
  }
  if (tempoWatchTimer) {
    clearInterval(tempoWatchTimer);
    tempoWatchTimer = null;
  }
  isPlaying = false;
  document.getElementById("status").innerText = "å¾…æ©Ÿä¸­...";
}
</script>
</body>
</html>
