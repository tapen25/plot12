<button id="start">Start (iOSã¯è¦ã‚¿ãƒƒãƒ—)</button>
<button id="stop">Stop</button>
<div id="status">åœæ­¢ä¸­</div>
<div id="debug">BPM: 0</div>

<script>
let audioCtx;
let usePatternA = true;
let isPlaying = false; 
let currentNoteIndex = 0; 
let smoothedBPM = 60; 

// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ç”¨å¤‰æ•°
let nextNoteTime = 0.0;      // æ¬¡ã®éŸ³ãŒé³´ã‚‹ã¹ãçµ¶å¯¾æ™‚åˆ»
let timerID;                 // requestAnimationFrame/setIntervalç”¨
const scheduleAheadTime = 0.1; // 0.1ç§’å…ˆã¾ã§äºˆç´„ã™ã‚‹
const lookahead = 25.0;      // 25msã”ã¨ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ã‚’å›ã™

// ã‚»ãƒ³ã‚µãƒ¼å±¥æ­´
let motionHistory = [];
const HISTORY_DURATION = 2000;

// ãƒãƒ¼ãƒˆå®šç¾©ï¼ˆå¤‰æ›´ãªã—ï¼‰
const patterns = {
  A: ["F3","Bb3","C4","D4", "C4","Bb3", "A3","G3"],
  B: ["G3","D4","Eb4","D4", "C4","Bb3", "Bb3","D3", "Bb3"]
};
// ãƒªã‚ºãƒ å®šç¾©ï¼ˆå¤‰æ›´ãªã—ï¼‰
const durations = [0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 1.0, 1.0];

// å‘¨æ³¢æ•°å¤‰æ›ï¼ˆå¤‰æ›´ãªã—ï¼‰
function noteToFreq(note, offset = 0) {
  const map = {
    G3: -14, A3: -12, Bb3: -10, B3: -10, // Bb3ã‚’è¿½åŠ (B3ã¨åŒã˜æ‰±ã„ã«ä»®å®šã€å¿…è¦ã«å¿œã˜ä¿®æ­£)
    C4: -9,  D4: -7, Eb4: -6, E4: -5, F4: -4, G4: -2, A4: 0, B4: 2,
    C5: 3, D3: -26 // D3ãªã©ã‚’é©å½“ã«è¿½åŠ (G3ã‚ˆã‚Šä¸‹)
  };
  // â€»æ³¨: å…ƒã‚³ãƒ¼ãƒ‰ã®Mapã«ãªã„éŸ³ç¨‹(Bb3, Eb4, D3)ãŒã‚ã£ãŸãŸã‚è£œå®Œã—ã¾ã—ãŸ
  // å³å¯†ãªå‘¨æ³¢æ•°ã¯å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ã—ã¦ãã ã•ã„
  
  let semitone = map[note] !== undefined ? map[note] : 0;
  semitone += offset;
  return 440 * Math.pow(2, semitone/12);
}

document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    await DeviceMotionEvent.requestPermission();
  }
  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "ã‚·ã‚§ã‚¤ã‚¯ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼";
};

document.getElementById("stop").onclick = () => {
  isPlaying = false;
  clearTimeout(timerID);
  document.getElementById("status").innerText = "åœæ­¢";
};

// ---------------------------
// ã‚»ãƒ³ã‚µãƒ¼å‡¦ç†
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;
  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({ time: now, val: mag });
  motionHistory = motionHistory.filter(item => now - item.time < HISTORY_DURATION);

  let sum = 0;
  motionHistory.forEach(item => sum += item.val);
  const avgMag = sum / motionHistory.length || 0;

  smoothedBPM = mapAccelToBPM(avgMag);
  
  const isHighSpeed = smoothedBPM >= 120;
  document.getElementById("debug").innerText = `Avg BPM: ${Math.floor(smoothedBPM)} ${isHighSpeed ? "ğŸ”¥HIGH" : ""}`;

  // ãƒˆãƒªã‚¬ãƒ¼åˆ¤å®šï¼šåœæ­¢ä¸­ã«å¼·ãæŒ¯ã£ãŸã‚‰é–‹å§‹
  if (!isPlaying && mag > 15) { 
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let bpm = 100 + (a - 10) * 8; 
  if (bpm < 60) bpm = 60;
  if (bpm > 200) bpm = 200;
  return bpm;
}

// ---------------------------
// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹å‡¦ç†
// ---------------------------
function startSequence() {
  if (isPlaying) return;
  
  isPlaying = true;
  currentNoteIndex = 0;
  usePatternA = true; // æœ€åˆã¯Aã‹ã‚‰
  
  // æ¬¡ã®éŸ³ãŒé³´ã‚‹æ™‚é–“ã‚’ã€Œç¾åœ¨æ™‚åˆ» + å°‘ã—ä½™è£•ã€ã«è¨­å®š
  nextNoteTime = audioCtx.currentTime + 0.1;
  
  // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼é–‹å§‹
  scheduler();
}

// ---------------------------
// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼ï¼ˆå¿ƒè‡“éƒ¨ï¼‰
// ---------------------------
function scheduler() {
  // åœæ­¢ä¸­ãªã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
  if (!isPlaying) return;

  // "scheduleAheadTime" ç§’å…ˆã¾ã§ã«ã‚ã‚‹éŸ³ç¬¦ã‚’ã™ã¹ã¦äºˆç´„ã™ã‚‹
  while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
    scheduleNote(currentNoteIndex, nextNoteTime);
    nextNote();
  }
  
  // ä¸€å®šæ™‚é–“å¾Œã«ã¾ãŸãƒã‚§ãƒƒã‚¯ï¼ˆsetTimeoutã§ãƒ«ãƒ¼ãƒ—ï¼‰
  timerID = setTimeout(scheduler, lookahead);
}

// æ¬¡ã®éŸ³ã®æ™‚é–“ã‚’è¨ˆç®—ã—ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é€²ã‚ã‚‹
function nextNote() {
  const currentPattern = usePatternA ? patterns.A : patterns.B;
  const durationVal = durations[currentNoteIndex]; // 1.0 = 4åˆ†éŸ³ç¬¦

  // â˜…ã“ã“ã§ã€Œæ¬¡ã®éŸ³ã®æ™‚é–“ã€ã‚’ä»Šã®BPMã«åŸºã¥ã„ã¦åŠ ç®—ã™ã‚‹
  const secondsPerBeat = 60.0 / smoothedBPM;
  nextNoteTime += durationVal * secondsPerBeat;

  currentNoteIndex++;

  // ãƒ‘ã‚¿ãƒ¼ãƒ³çµ‚äº†æ™‚ã®å‡¦ç†
  if (currentNoteIndex >= currentPattern.length) {
    currentNoteIndex = 0;
    usePatternA = !usePatternA; // Aã¨Bã‚’äº¤äº’ã«
  }
}

// ---------------------------
// éŸ³ã®äºˆç´„ã¨æç”»äºˆç´„
// ---------------------------
function scheduleNote(index, time) {
  const currentPattern = usePatternA ? patterns.A : patterns.B;
  
  // éŸ³ç¨‹ã¨é•·ã•ã®æ±ºå®š
  const noteName = currentPattern[index];
  
  // â€»ã“ã®æ™‚ç‚¹ã®BPMã§é•·ã•ã‚’æ±ºã‚ã‚‹ï¼ˆéŸ³è‰²ã¯ãƒ”ãƒƒãƒã‚ªãƒ•ã‚»ãƒƒãƒˆãªã©ã§å¤‰åŒ–å¯èƒ½ï¼‰
  const pitchOffset = (smoothedBPM >= 120) ? 1 : 0;
  const freq = noteToFreq(noteName, pitchOffset);
  
  // éŸ³ã®é•·ã•ï¼ˆç™ºéŸ³æ™‚é–“ï¼‰
  const durationVal = durations[index];
  const secondsPerBeat = 60.0 / smoothedBPM;
  const noteDuration = durationVal * secondsPerBeat;

  // Web Audioã§äºˆç´„
  playTone(freq, time, noteDuration);

  // ç”»é¢è¡¨ç¤ºã®åŒæœŸï¼ˆéŸ³ãŒé³´ã‚‹æ™‚åˆ»ã«åˆã‚ã›ã¦è¡¨ç¤ºã‚’å¤‰ãˆã‚‹ï¼‰
  // requestAnimationFrameç­‰ã‚’ä½¿ã†ã®ãŒç†æƒ³ã§ã™ãŒã€ç°¡æ˜“çš„ã«setTimeoutã§åŒæœŸã•ã›ã¾ã™
  const drawDelay = (time - audioCtx.currentTime) * 1000;
  setTimeout(() => {
    if(!isPlaying) return;
    document.getElementById("status").innerText = 
      `å†ç”Ÿä¸­: ${usePatternA?"A":"B"} (${index+1}/${currentPattern.length})`;
  }, Math.max(0, drawDelay));
}

function playTone(freq, time, duration) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = "triangle"; 
  osc.frequency.setValueAtTime(freq, time); // ã“ã“é‡è¦: äºˆç´„æ™‚åˆ»ã«è¨­å®š

  const soundEnd = time + (duration * 0.9);

  // ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—
  gain.gain.setValueAtTime(0, time);
  gain.gain.linearRampToValueAtTime(0.3, time + 0.04); 
  gain.gain.exponentialRampToValueAtTime(0.001, soundEnd);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + duration);
}
</script>