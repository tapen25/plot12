<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>BPMè¿½å¾“ã‚·ãƒ¼ã‚±ãƒ³ã‚µ</title>
</head>
<body>
<button id="start">Start (iOSã¯è¦ã‚¿ãƒƒãƒ—)</button>
<div id="status">åœæ­¢ä¸­</div>
<div id="debug">BPM: 0</div>

<script>
let audioCtx;
let usePatternA = true;
let isPlaying = false;
let smoothedBPM = 60;
let motionHistory = [];
const HISTORY_DURATION = 2000; // ms

// ãƒ‘ã‚¿ãƒ¼ãƒ³ / ãƒªã‚ºãƒ 
const patterns = {
  A: ["D4","C4","B3","D4", "C4","A3", "G3","A3", "B3"],
  B: ["D4","C4","B3","D4", "C4","A3", "G3","B3", "G3"]
};
const durations = [0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.5, 0.5, 1.0];

// ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ç®¡ç†
let tempoAtStart = 120;       // ç¾åœ¨é©ç”¨ä¸­ã®ãƒ†ãƒ³ãƒï¼ˆå°ç¯€é ­ã§æ›´æ–°ï¼‰
let pendingTempo = null;      // æ¬¡ã®å°ç¯€é ­ã§é©ç”¨ã™ã‚‹ãƒ†ãƒ³ãƒï¼ˆnullã§æœªäºˆç´„ï¼‰
let sequenceStartTime = 0;    // æ¬¡ãƒ‘ã‚¿ãƒ¼ãƒ³ã®çµ¶å¯¾é–‹å§‹æ™‚åˆ» (audioCtx.currentTime åŸºæº–)
let scheduledFinishTimer = null;
let tempoWatchTimer = null;
let devMotionAttached = false;

// ãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡ï¼ˆè¶³éŸ³ç”¨ï¼‰
let noiseBuffer = null;

// ---------------------------
// éŸ³å -> å‘¨æ³¢æ•°
// ---------------------------
function noteToFreq(note, offset = 0) {
  const map = {
    G3: -14, A3: -12, B3: -10,
    C4: -9,  D4: -7,  E4: -5, F4: -4, G4: -2, A4: 0, B4: 2,
    C5: 3
  };
  let semitone = map[note];
  if (semitone === undefined) semitone = 0;
  semitone += offset;
  return 440 * Math.pow(2, semitone / 12);
}

// ---------------------------
// ãƒã‚¤ã‚ºãƒãƒƒãƒ•ã‚¡ä½œæˆï¼ˆè¶³éŸ³ç”¨ï¼‰
// ---------------------------
function ensureNoiseBuffer() {
  if (!audioCtx || noiseBuffer) return;
  const len = audioCtx.sampleRate * 0.2; // 0.2s ã®çŸ­ã„ãƒã‚¤ã‚º
  const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++) {
    // çŸ­ã„ãƒ©ãƒ³ãƒ€ãƒ ãƒã‚¤ã‚ºï¼ˆå¾ã€…ã«æ¸›è¡°ï¼‰
    data[i] = (Math.random() * 2 - 1) * (1 - i / len);
  }
  noiseBuffer = buf;
}

// ---------------------------
// ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³
// ---------------------------
document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }

  ensureNoiseBuffer();

  if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
    try { await DeviceMotionEvent.requestPermission(); } catch(e) { /* iOS ã§æ‹’å¦ã•ã‚ŒãŸã‚‰ç„¡è¦– */ }
  }
  if (!devMotionAttached) {
    window.addEventListener("devicemotion", handleMotion);
    devMotionAttached = true;
  }

  if (!isPlaying) {
    startSequence();
  }
};

// ---------------------------
// ã‚»ãƒ³ã‚µãƒ¼å‡¦ç†ï¼ˆ2ç§’å¹³å‡ã§BPMç®—å‡ºï¼‰
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;
  const mag = Math.sqrt((acc.x||0)**2 + (acc.y||0)**2 + (acc.z||0)**2);
  const now = performance.now();
  motionHistory.push({ time: now, val: mag });
  motionHistory = motionHistory.filter(item => now - item.time < HISTORY_DURATION);
  let sum = 0;
  motionHistory.forEach(item => sum += item.val);
  const avgMag = sum / (motionHistory.length || 1);
  smoothedBPM = mapAccelToBPM(avgMag);
  const isHighSpeed = smoothedBPM >= 120;
  document.getElementById("debug").innerText = `Avg BPM: ${Math.floor(smoothedBPM)} ${isHighSpeed ? "ğŸ”¥HIGH" : ""}`;

  // åœæ­¢ä¸­ã§å¼·ãæŒ¯ã£ãŸã‚‰é–‹å§‹
  if (!isPlaying && mag > 15) {
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let bpm = 100 + (a - 10) * 8;
  if (bpm < 60) bpm = 60;
  if (bpm > 200) bpm = 200;
  return bpm;
}

// ---------------------------
// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹ï¼ˆæœ€åˆã®å°ç¯€ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼‰
// ---------------------------
function startSequence() {
  if (!audioCtx) return;
  isPlaying = true;
  usePatternA = true;
  tempoAtStart = Math.max(60, Math.min(200, Math.round(smoothedBPM)));
  pendingTempo = null;
  sequenceStartTime = audioCtx.currentTime + 0.05;
  schedulePattern(usePatternA, tempoAtStart, sequenceStartTime);

  // ãƒ†ãƒ³ãƒå¤‰åŒ–ã‚’ç›£è¦–ã—ã¦ã€Œæ¬¡ã®å°ç¯€é ­ã€ã§é©ç”¨ã™ã‚‹ãŸã‚ã®ã‚¿ã‚¤ãƒãƒ¼
  if (tempoWatchTimer) clearInterval(tempoWatchTimer);
  tempoWatchTimer = setInterval(() => {
    const bpmRounded = Math.max(60, Math.min(200, Math.round(smoothedBPM)));
    if (Math.abs(bpmRounded - tempoAtStart) >= 2) {
      pendingTempo = bpmRounded;
    }
  }, 150);
}

// ---------------------------
// ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’çµ¶å¯¾æ™‚é–“ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆ1ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†ã®ã¿ï¼‰
// ---------------------------
function schedulePattern(isA, tempo, startTime) {
  if (!audioCtx) return;
  const pattern = isA ? patterns.A : patterns.B;
  let accumBeats = 0;
  const beatDuration = 60 / tempo;

  // éŸ³ç¬¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  pattern.forEach((noteName, idx) => {
    const durationVal = durations[idx];
    const noteStart = startTime + accumBeats * beatDuration;
    const noteLen = beatDuration * durationVal;

    // åŸºæœ¬ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    const baseOffset = (tempo >= 120) ? 1 : 0;

    // ãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼é¸å®šï¼ˆãƒ†ãƒ³ãƒåŸºæº–ã§æ±ºå®šï¼‰
    let harmonyIntervals = [0];
    if (tempo >= 160) {
      harmonyIntervals = [0, 4, 7];
    } else if (tempo >= 120) {
      harmonyIntervals = [0, 4];
    }
    const freqs = harmonyIntervals.map(i => noteToFreq(noteName, baseOffset + i));

    // éŸ³ã‚’äºˆç´„
    playTone(freqs, noteStart, noteLen);

    // UIæ›´æ–°ï¼ˆè©²å½“ãƒãƒ¼ãƒˆãŒå§‹ã¾ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§è¡¨ç¤ºï¼‰
    const uiDelay = (noteStart - audioCtx.currentTime) * 1000;
    setTimeout(() => {
      document.getElementById("status").innerText =
        `å†ç”Ÿä¸­: ${isA ? "A" : "B"} (${idx+1}/${pattern.length}) ${harmonyIntervals.length>1 ? "ï¼‹ãƒãƒ¢ãƒª" : ""}`;
    }, Math.max(0, uiDelay));

    accumBeats += durationVal;
  });

  // è¶³éŸ³ã‚’ãƒ“ãƒ¼ãƒˆï¼ˆ1æ‹ã”ã¨ï¼‰ã§ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
  // å¼·èª¿ï¼ˆã‚¢ã‚¯ã‚»ãƒ³ãƒˆï¼‰ã¯å„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®1æ‹ç›®ã«ã®ã¿å…¥ã‚Œã‚‹
  const totalBeats = Math.ceil(accumBeats);
  for (let b = 0; b < totalBeats; b++) {
    const t = startTime + b * beatDuration;
    const accent = (b === 0); // 1æ‹ç›®ã‚’å¼·ã
    playFootstep(t, accent);
  }

  // æ¬¡ãƒ‘ã‚¿ãƒ¼ãƒ³é–‹å§‹ã®äºˆç´„ï¼ˆå°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
  const totalDuration = accumBeats * beatDuration;
  if (scheduledFinishTimer) clearTimeout(scheduledFinishTimer);
  const finishDelay = (startTime + totalDuration - audioCtx.currentTime) * 1000 + 20;
  scheduledFinishTimer = setTimeout(() => {
    onPatternEnd();
  }, Math.max(0, finishDelay));
}

// ---------------------------
// è¶³éŸ³å†ç”Ÿï¼ˆãƒã‚¤ã‚ºãƒãƒ¼ã‚¹ãƒˆ + ãƒ•ã‚£ãƒ«ã‚¿ + ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼‰
// ---------------------------
function playFootstep(time, accent = false) {
  if (!audioCtx || !noiseBuffer) return;
  const src = audioCtx.createBufferSource();
  src.buffer = noiseBuffer;

  const filter = audioCtx.createBiquadFilter();
  filter.type = "bandpass";
  filter.frequency.value = accent ? 900 : 700;
  filter.Q = 0.7;

  const gain = audioCtx.createGain();
  const baseGain = accent ? 0.35 : 0.18;
  // çŸ­ã„ã‚¢ã‚¿ãƒƒã‚¯ã§è‡ªç„¶ãªæ¸›è¡°
  gain.gain.setValueAtTime(0.0001, time);
  gain.gain.exponentialRampToValueAtTime(baseGain, time + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);

  src.connect(filter).connect(gain).connect(audioCtx.destination);
  src.start(time);
  src.stop(time + 0.15);
}

// ---------------------------
// ã‚µã‚¦ãƒ³ãƒ‰ç”Ÿæˆï¼ˆæ—¢å­˜ã®å®Ÿè£…ã‚’æµç”¨ï¼‰
// ---------------------------
// ---------------------------
// ã‚µã‚¦ãƒ³ãƒ‰ç”Ÿæˆï¼šåŒã˜ãƒ•ãƒ¬ãƒ¼ã‚ºã‚’é•ã†æ¥½å™¨ã§é³´ã‚‰ã™
// ---------------------------
function playTone(freqs, time, duration) {
  // ä»Šå›ã¯ freqs[0] ã‚’ä½¿ã†ï¼ˆãƒãƒ¼ãƒ¢ãƒ‹ãƒ¼ã¯ freqs é…åˆ—ã§å‡¦ç†æ¸ˆã¿ãªã‚‰åˆ¥å®Ÿè£…ã¸å¤‰æ›´å¯ï¼‰
  const freq = freqs[0];

  // æ¥½å™¨ãƒ¬ã‚¤ãƒ¤ãƒ¼
  const instruments = [
    { type: "triangle", gain: 0.30 },
    { type: "square",   gain: 0.15 },
    { type: "sine",     gain: 0.12 }
  ];

  instruments.forEach(inst => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();

    osc.type = inst.type;
    osc.frequency.value = freq;

    // ã‚¢ã‚¿ãƒƒã‚¯ & ãƒªãƒªãƒ¼ã‚¹
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(inst.gain, time + 0.03);
    gain.gain.exponentialRampToValueAtTime(0.001, time + duration * 0.9);

    osc.connect(gain).connect(audioCtx.destination);
    osc.start(time);
    osc.stop(time + duration);
  });
}


// ---------------------------
// åœæ­¢å‡¦ç†ï¼ˆå¿…è¦ãªã‚‰å¤–éƒ¨ã§å‘¼ã¹ã‚‹ï¼‰
// ---------------------------
function finishSequence() {
  if (scheduledFinishTimer) {
    clearTimeout(scheduledFinishTimer);
    scheduledFinishTimer = null;
  }
  if (tempoWatchTimer) {
    clearInterval(tempoWatchTimer);
    tempoWatchTimer = null;
  }
  isPlaying = false;
  document.getElementById("status").innerText = "å¾…æ©Ÿä¸­...";
}
</script>
</body>
</html>