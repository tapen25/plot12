<button id="start">Start (iOSã¯è¦ã‚¿ãƒƒãƒ—)</button>
<div id="status">åœæ­¢ä¸­</div>
<div id="debug">BPM: 0</div>

<script>
let audioCtx;
let isPlaying = false;

// ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ‡æ›¿
let usePatternA = true;

// å¹³å‡BPMï¼ˆ2ç§’å¹³å‡ï¼‰
let smoothedBPM = 60;

// åŠ é€Ÿåº¦ã®å±¥æ­´
let motionHistory = [];
const HISTORY_DURATION = 2000;

// å°ç¯€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ç”¨
let nextBarTime = 0;
const beatsPerMeasure = 4;

// ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
const patterns = {
  A: ["D4","C4","B3","D4","C4","A3","G3","A3","B3"],
  B: ["D4","C4","B3","D4","C4","A3","G3","B3","G3"]
};

// ãƒªã‚ºãƒ ï¼ˆ4åˆ†ï¼1.0ï¼‰
const durations = [0.25,0.25,0.25,0.25,0.5,0.5,0.5,0.5,1.0];

// ---------------------------
// éŸ³åâ†’å‘¨æ³¢æ•°
// ---------------------------
function noteToFreq(note, offset = 0) {
  const map = {
    G3:-14, A3:-12, B3:-10,
    C4:-9,  D4:-7,  E4:-5, F4:-4, G4:-2, A4:0, B4:2,
    C5:3
  };
  let semitone = map[note] ?? 0;
  semitone += offset;
  return 440 * Math.pow(2, semitone/12);
}

document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
  }

  if (typeof DeviceMotionEvent.requestPermission === "function") {
    await DeviceMotionEvent.requestPermission();
  }

  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "ã‚»ãƒ³ã‚µãƒ¼å¾…æ©Ÿä¸­...";
};

// ---------------------------
// ã‚»ãƒ³ã‚µãƒ¼å‡¦ç† â†’ å¹³å‡BPMç®—å‡º
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;

  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({time: now, val: mag});
  motionHistory = motionHistory.filter(i => now - i.time < HISTORY_DURATION);

  let sum = 0;
  motionHistory.forEach(i => sum += i.val);
  const avg = sum / motionHistory.length || 0;

  smoothedBPM = mapAccelToBPM(avg);

  const isHigh = smoothedBPM >= 120;
  document.getElementById("debug").innerText =
    `Avg BPM: ${Math.floor(smoothedBPM)} ${isHigh?"ğŸ”¥HIGH":""}`;

  // é–‹å§‹ãƒˆãƒªã‚¬ãƒ¼
  if (!isPlaying && mag > 15) {
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let bpm = 100 + (a - 10) * 8;
  if (bpm < 60) bpm = 60;
  if (bpm > 200) bpm = 200;
  return bpm;
}

// ---------------------------
// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹
// ---------------------------
function startSequence() {
  isPlaying = true;
  nextBarTime = audioCtx.currentTime + 0.1; // åˆå›ã®å°ç¯€é ­
  document.getElementById("status").innerText = "å†ç”Ÿä¸­...";
}

// ---------------------------
// 1å°ç¯€åˆ†ã‚’ã¾ã¨ã‚ã¦ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
// ---------------------------
function scheduleBar() {
  const pattern = usePatternA ? patterns.A : patterns.B;
  const beatDur = 60 / smoothedBPM;
  const now = audioCtx.currentTime;

  // åˆå›å‡¦ç†ï¼šnextBarTime ãŒéå»ã ã£ãŸã‚‰è£œæ­£
  if (nextBarTime < now) {
    nextBarTime = now + 0.05;
  }

  let cursor = nextBarTime;
  const totalBeats = durations.reduce((a,b)=>a+b, 0);

  for (let i = 0; i < pattern.length; i++) {
    const beatLen = durations[i];
    const durSec = beatLen * beatDur;

    const pitchOffset = smoothedBPM >= 120 ? 1 : 0;
    const freq = noteToFreq(pattern[i], pitchOffset);

    playTone(freq, cursor, durSec);
    cursor += durSec;
  }

  // æ¬¡ã®å°ç¯€é ­ã¸
  nextBarTime += totalBeats * beatDur;

  document.getElementById("status").innerText =
    `å†ç”Ÿä¸­: ${usePatternA ? "A" : "B"} (1å°ç¯€å®Œäº†)`;

  usePatternA = !usePatternA;
}

// ---------------------------
// éŸ³å†ç”Ÿï¼ˆä¸‰è§’æ³¢ã§æŸ”ã‚‰ã‹ã„éŸ³ï¼‰
// ---------------------------
function playTone(freq, time, dur) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.type = "triangle";
  osc.frequency.value = freq;

  const end = time + dur * 0.9;

  gain.gain.setValueAtTime(0, time);
  gain.gain.linearRampToValueAtTime(0.3, time + 0.04);
  gain.gain.exponentialRampToValueAtTime(0.001, end);

  osc.connect(gain).connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + dur);
}

// ---------------------------
// 25msã”ã¨ã«å…ˆèª­ã¿ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
// ---------------------------
setInterval(() => {
  if (!isPlaying) return;
  const now = audioCtx.currentTime;
  if (nextBarTime - now < 0.1) {
    scheduleBar();
  }
}, 25);
</script>
